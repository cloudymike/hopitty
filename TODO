Where to start
===============
starttst.py: Change starttst.py to a nosetests file
runscan.py: remove all memcache.Client, and use dataMemcache

runscan.py: add quickmode to runscan and create a toplevel test, using file in src/tests/Cloud.bsmx

dataMemcache: create nosetests for all methods. write-read-compare. Validate type of data

Create a maintenance programs module that is similar to recipeliststatus, but
reading the json files instead.

Add test button to runcontrol page. This will do a quick run and reality check of the recipe.

coverage
  covertests
  Start with all files not listed, should they be removed?
  Create a nosetests only option of covertests
  Identify lines not covered, add nosetests or remove or mark as not testable
     hardware lines. try to minimize the amount


====== Laidback work =====
Remove unused code
    Commented out code
    import statements with yellow triangle

pepme

Increase coverage     
    
    
 
====== Less immediate =====
stages should probably be a class
Look for unused code as includes etc.




====== Post brew issues and observations =======

brew 130309
After brew is done programs exit, where?

stages page has a links for number, why?
DTHe blue on green does not work.




after brew 130202
Post cleaning not working as it relies on scale.

after brew 130126
Add a link to gravity/temperature calculator on the web

Add key mashing data to mash status page from recipe
  Equipment temperature
  (mash schedule..)

====== To Fix =======
refactoring
  stages class ( & module)

refactoring
  runctrl.py, breakout as a def or class
  Should be possible to call (as needed when recipelist is done

Break out getop and use an options dictionary

How to start a brew?

cloudrecipe.py as standalone exec

Add the user for the path to the home dir bsmx file as an input option
to recipeScanner

===== Hardware Issues =====
Hardware are sometimes failing at startup. Test this in loop.

X10 controller hangs at startup at times. Debug this. It seems like a reboot
fixes the problem.

Consider create a HW check mode, that will fail if not all hardware sensors and 
controllers are OK


==== Checks =====
  mutex (link to other controller that should NOT be activated at same time)
  max values (as pump volume)
  Timeouts?
  watch dogs? Water checks?


==== Unknown ====
dict_.get('key2', "Key doesn't exist")

Watchdog to shut all down?


